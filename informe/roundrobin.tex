\section{Round Robin scheduling}

\begin{quote}
	\textit{Round robin es un método para seleccionar todos los elementos en un grupo de manera equitativa y en un orden racional, normalmente comenzando por el primer elemento de la lista hasta llegar al último y empezando de nuevo desde el primer elemento.} 
	
	\textit{El nombre del algoritmo viene del principio de Round-Roubin conocido de otros campos, donde cada persona toma una parte de un algo compartido en cantidades parejas.}\footnote{Fuente: Wikipedia: La enciclopedia libre.}
	
\end{quote}
	
	El concepto del algoritmo se basa en la definición de un intervalo de tiempo llamado \textit{quantum} cuya duración es variable. Éste suele implementarse mediante un temporizador que genera una interrupción cuando se agota el tiempo.
	
	Las tareas se disponen en una cola simulando una estuctura circular; la organización de la misma es FIFO. Si una tarea agota su tiempo de procesamiento antes de finalizar el \textit{quantum}, ésta es desalojada y en su lugar se asigna otra tarea.
	
	Vale destacar que este algoritmo, si bien tiene un tiempo de espera grande, garantiza un reparto equitativo del procesador entre todas las tareas lo cual lo hace libre de inanición.

\subsection{Implementación propuesta}

Nuestra implementación del scheduler contiene tres métodos: \textit{load(pid), unblock(pid) y tick(motivo)}, además de una cola para los procesos:

\begin{itemize}
	\item El método \textit{load(pid)} introduce una tarea con identificador \textit{pid} en la cola de tareas.
	
	\item El método \textit{unblock(pid)} avisa al \textit{scheduler} cuando la tarea con identificador \textit{pid} deja de estar bloqueada introduciéndola en la cola de tareas.
	
	\item El método \textit{tick(motivo)} se ejecuta por cada tick del reloj de la máquina el simulador. El parámetro \textbf{motivo} indica lo que ocurrió con la tarea que ocupaba el CPU el ciclo de reloj anterior:
	
	\begin{itemize}
		\item Si el \textbf{motivo} es \textit{block o exit}: se reinicializa el \textit{quantum} y se saca la tarea de la cola. Cuando esto sucede y la cola queda vacía, se devuelve \verb|idle_task| ; de lo contrario el \textit{pid} de la tarea que ocupará el próximo ciclo de reloj.

		\item Si el \textbf{motivo} es \textit{tick}: si la tarea no era \verb|idle_task| y su \textit{quantum} finalizó, se devuelve el \textit{pid} de la tarea siguiente en la cola. Si todavía le queda tiempo para procesar, el \textit{pid} de la tarea que se procesó es el mismo que se retorna.
		
		Si la tarea era \verb|idle_task| y la cola está vacía, entonces continúa ejecutándose la misma tarea; de lo contrario se devuelve el \textit{pid} de la primer tarea de la cola y se reinicializa el \textit{quantum}.
	\end{itemize}

\end{itemize}

\subsection{Diagrama de estados}

\begin{center}
\includegraphics[scale=0.5]{estados.png}
\end{center}
 
En este diagrama de estados podemos apreciar el desalojo de tareas así como 

\subsection{Análisis del algoritmo}

Al realizar varias pruebas pudimos comprobar que a medida que aumentamos el \textit{quantum} haciéndolo proporcional al total de \textit{ticks} de las tareas, el tiempo necesario para que todas finalicen disminuye. Además podemos ver que el \textit{throughput} también mejora: a medida que el \textit{quantum} aumenta la proporción de tareas finalizadas por intervalo es crece.

Esto es lo que podemos apreciar en los gráficos siguientes: las tareas, de tipo \verb|TaskBatch|, duran 10 \textit{ticks} y la cantidad de \textit{blocks} aumenta de 0 a 9. 

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{./graficos/out_batch_fijo1.png}
\caption{Algoritmo Round robin con \textit{quantum} 1}
\end{figure}  

Como podemos apreciar este caso las tareas tardan alrededor de 200 \textit{ticks} de reloj en terminar. En cuanto al \textit{throughput} podemos ver que es bastante malo ya que todas las tareas terminan en un mismo intervalo, el último. 

 
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{./graficos/out_batch_fijo9.png}
\caption{Algoritmo Round robin con \textit{quantum} 9} 
\end{figure}


En este caso las tareas tardan alrededor de 160 \textit{ticks} de reloj en terminar y con respecto al \textit{throughput} vemos que mejora notablemente ya que la cantidad de tareas que finalizan por intervalo es mas uniforme. 


